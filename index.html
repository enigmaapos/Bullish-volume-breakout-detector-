<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Volume Break Detector — Top-N green + Candle above EMA200 (15m) — 24h red-break (quoteVol)</title>
  <style>
    body{font-family:Inter,system-ui,Arial;margin:12px;background:#0f1720;color:#e6eef8}
    .card{background:#0b1220;padding:12px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.6);margin-bottom:12px}
    h1{font-size:18px;margin:0 0 8px}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,.05);text-align:left}
    .ok{color:#2dd4bf}
    .warn{color:#f59e0b}
    .bad{color:#fb7185}
    .match-row{background:linear-gradient(90deg, rgba(45,212,191,0.06), transparent)}
    button{background:#111827;color:#e6eef8;padding:8px 10px;border-radius:6px;border:1px solid rgba(255,255,255,.04);cursor:pointer}
    input,select,textarea{background:#081226;color:#e6eef8;border:1px solid rgba(255,255,255,.04);padding:6px;border-radius:6px}
    small{color:#9fb3cc}
    pre{white-space:pre-wrap; max-height:220px; overflow:auto}
    .debug{font-size:13px;color:#9fb3cc;margin-top:8px}
    .notify{padding:8px;border-radius:6px;background:#072a1d;color:#bff3e8;margin-bottom:8px}
  </style>
</head>
<body>
  <div class="card">
    <h1>Volume Break Detector — Top-N green + Candle above EMA200 (15m)</h1>
    <p>Strict 24h red-break detector (uses quote-volume): finds the highest quote-volume RED candle in the last 24h, looks for the earliest green that breaks that red quote-volume, and applies your stop/ignore rules.</p>

    <div style="display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap">
      <label>Top N: <input id="topN" type="number" value="30" min="1" max="200" style="width:80px"/></label>
      <label>Polling (sec): <input id="pollSec" type="number" value="60" min="10" style="width:80px"/></label>
      <label>Batch size: <input id="batchSize" type="number" value="3" min="1" max="8" style="width:60px"/></label>
      <label>Vol ratio (green >= red *): <input id="volRatio" type="number" value="1.0" step="0.1" style="width:80px"/></label>
      <label><input id="autoOpen" type="checkbox" /> Auto-open on match</label>
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <small id="status">Idle</small>
    </div>

    <div class="debug" id="debugLine">Debug: —</div>
    <div style="margin-top:8px">
      <small id="blacklistInfo">Blacklist: 0 symbols filtered</small> &nbsp;•&nbsp;
      <small id="topInfo">Top-N selected: 0</small> &nbsp;•&nbsp;
      <small id="emaInfo">EMA-OK: 0 (last close > EMA200)</small>
    </div>
  </div>

  <div class="card">
    <h2>Matches</h2>
    <div id="matches">No results yet</div>
  </div>

  <div class="card">
    <h2>EMA-Positive Symbols (phase A)</h2>
    <div id="emaSymbols">None yet</div>
  </div>

  <div class="card">
    <h2>Quick Test (single symbol)</h2>
    <div style="display:flex;gap:8px;align-items:center">
      <input id="testSymbol" value="BTCUSDT" style="width:140px"/>
      <button id="testBtn">Test Symbol</button>
      <small id="testStatus">—</small>
    </div>
    <pre id="testOut"></pre>
  </div>

  <div class="card">
    <h2>Blacklist (editable)</h2>
    <textarea id="blacklistArea" rows="6" style="width:100%;font-family:monospace"></textarea>
    <div style="margin-top:8px"><button id="updateBlacklistBtn">Update Blacklist</button></div>
  </div>

<script>
/* ---------------------------
   Blacklist (initial)
   --------------------------- */
let blacklist = [
  "ALPACAUSDT","BNXUSDT","ALPHAUSDT","OCEANUSDT","DGBUSDT","AGIXUSDT","LINAUSDT",
  "LOKAUSDT","KEYUSDT","MDTUSDT","LOOMUSDT","RENUSDT","OMNIUSDT","SLERFUSDT",
  "STMXUSDT","UXLINKUSDT","BSWUSDT","NEIROETHUSDT","VIDTUSDT","TROYUSDT",
  "BAKEUSDT","AMBUSDT","MEMEFIUSDT","NULSUSDT","HIFIUSDT","LEVERUSDT","XEMUSDT",
  "STRAXUSDT","COMBOUSDT","AI16ZUSDT","MILKUSDT","TOKENUSDT","SXPUSDT","MYROUSDT","1000XUSDT","DARUSDT"
];

document.addEventListener('DOMContentLoaded', ()=> {
  document.getElementById('blacklistArea').value = blacklist.join('\n');
  document.getElementById('blacklistInfo').textContent = `Blacklist: ${blacklist.length} symbols filtered`;
});

/* ---------------------------
   Config + utilities
   --------------------------- */
const API_BASE = 'https://fapi.binance.com';
const INTERVAL = '15m';
const KLINES_LIMIT = 300; // fetch 300 to compute EMA200
let controller = { running:false };

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
function safeNum(v){ return Number(String(v)); }
function fmt(n){ // friendly big number
  if(n == null || isNaN(n)) return '-';
  if(n >= 1e9) return (n/1e9).toFixed(2)+'B';
  if(n >= 1e6) return (n/1e6).toFixed(2)+'M';
  if(n >= 1e3) return (n/1e3).toFixed(2)+'K';
  return Number(n).toLocaleString();
}
function fmtPrice(p){ if(p==null) return '-'; return Number(p).toPrecision(6); }
function fmtTime(ms){ try{ return new Date(ms).toLocaleString(); }catch(e){ return String(ms); } }

async function batchMap(items, fn, batchSize=3, delayMs=700){
  const out=[];
  for(let i=0;i<items.length;i+=batchSize){
    const batch = items.slice(i,i+batchSize);
    const promises = batch.map(x=>fn(x).catch(e=>({__err:e.message||String(e)})));
    const res = await Promise.all(promises);
    out.push(...res);
    if(i+batchSize < items.length) await sleep(delayMs);
  }
  return out;
}

/* ---------------------------
   EMA helpers
   --------------------------- */
function calcEMA(period, prices){
  const k = 2 / (period + 1);
  const out = new Array(prices.length).fill(null);
  if(prices.length === 0) return out;
  let seedSum = 0;
  const seedCount = Math.min(period, prices.length);
  for(let i=0;i<seedCount;i++) seedSum += prices[i];
  out[seedCount-1] = seedSum / seedCount;
  for(let i=seedCount;i<prices.length;i++){
    out[i] = (prices[i] - out[i-1]) * k + out[i-1];
  }
  return out;
}
function isLastCloseAboveEMA200(klines){
  const closes = klines.map(k => safeNum(k.close));
  if(closes.length < 210) return false;
  const ema200 = calcEMA(200, closes);
  const lastIdx = closes.length - 1;
  const lastEMA200 = ema200[lastIdx];
  const lastClose = closes[lastIdx];
  if(lastEMA200 == null) return false;
  return lastClose > lastEMA200;
}

/* ---------------------------
   fetchKlines: preserve quoteVolume (kline[7]) and fallback
   --------------------------- */
async function fetchKlines(symbol){
  const url = `${API_BASE}/fapi/v1/klines?symbol=${encodeURIComponent(symbol)}&interval=${INTERVAL}&limit=${KLINES_LIMIT}`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('klines failed: '+res.status+' for '+symbol);
  const data = await res.json();
  // columns: [0 openTime,1 open,2 high,3 low,4 close,5 baseVol,6 closeTime,7 quoteVol,8 trades, ...]
  return data.map(c=>({
    openTime: c[0],
    open: c[1],
    high: c[2],
    low: c[3],
    close: c[4],
    baseVol: c[5],
    closeTime: c[6],
    quoteVol: (c[7] !== undefined && c[7] !== null) ? c[7] : null,
    trades: c[8]
  }));
}

/* ---------------------------
   STRICT: 24h highest-quoteVol RED -> earliest green-break detector
   - chooses highest **quote volume** red candle in last 24h (ignore green)
   - earliest later green with quoteVol >= red.quoteVol * volRatio
   - if earliestGreen.high < red.high -> STOP / ignore (broken earlier at lower price)
   - else if earliestGreen.high < dayHigh -> MATCH
   - else -> ignore (green made new day-high)
*/
function detect24hHighestRedBreak_quote(klines, volRatio=1.0){
  if(!klines || klines.length < 100) return null;
  const last24h = klines.slice(-96); // ~24h of 15m candles
  if(last24h.length === 0) return null;

  // compute day high (within last24h)
  let dayHigh = -Infinity;
  last24h.forEach(c => { const h = safeNum(c.high); if(h > dayHigh) dayHigh = h; });

  // numeric mapping with quoteVol (fallback to baseVol * close)
  const c = last24h.map(x => {
    const close = safeNum(x.close);
    const baseVol = safeNum(x.baseVol);
    let q = null;
    if(x.quoteVol !== undefined && x.quoteVol !== null && x.quoteVol !== '') {
      q = safeNum(x.quoteVol);
    }
    if(!q || q === 0) q = baseVol * close;
    return {
      openTime: x.openTime,
      open: safeNum(x.open),
      high: safeNum(x.high),
      low: safeNum(x.low),
      close,
      baseVol,
      quoteVol: q
    };
  });

  // find RED candles
  const redCandles = [];
  for(let i=0;i<c.length;i++){
    if(c[i].close < c[i].open) redCandles.push({idx:i, candle:c[i]});
  }
  if(redCandles.length === 0) return null;

  // choose red with max quoteVol
  let maxRed = redCandles[0];
  for(const r of redCandles){
    if(r.candle.quoteVol > maxRed.candle.quoteVol) maxRed = r;
  }
  const redIdx = maxRed.idx;
  const redC = maxRed.candle;

  // search earliest later GREEN with quoteVol >= red.quoteVol * volRatio
  let firstGreen = null;
  for(let j = redIdx + 1; j < c.length; j++){
    const later = c[j];
    if(later.close <= later.open) continue; // must be green
    if(later.quoteVol < redC.quoteVol * volRatio) continue;
    firstGreen = { idx: j, candle: later };
    break;
  }

  if(!firstGreen) return null;

  const g = firstGreen.candle;

  // If earliest green.high < red.high -> stop / ignore (user asked to stop detection)
  if(g.high < redC.high){
    return {
      found: false,
      reason: 'broken_earlier_at_lower_price',
      redIndex24h: redIdx, redCandle: redC,
      greenIndex24h: firstGreen.idx, greenCandle: g,
      redQuoteVol: redC.quoteVol, greenQuoteVol: g.quoteVol,
      dayHigh
    };
  }

  // require green.high < dayHigh (not new day high)
  if(g.high >= dayHigh){
    return {
      found: false,
      reason: 'green_made_day_high',
      redIndex24h: redIdx, redCandle: redC,
      greenIndex24h: firstGreen.idx, greenCandle: g,
      redQuoteVol: redC.quoteVol, greenQuoteVol: g.quoteVol,
      dayHigh
    };
  }

  // match
  return {
    found: true,
    redIndex24h: redIdx,
    redCandle: redC,
    greenIndex24h: firstGreen.idx,
    greenCandle: g,
    redQuoteVol: redC.quoteVol,
    greenQuoteVol: g.quoteVol,
    dayHigh
  };
}

/* ---------------------------
   Notifications
   --------------------------- */
async function makeBeep(){
  try{
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'sine'; o.frequency.value = 900; g.gain.value = 0.06;
    o.connect(g); g.connect(ctx.destination); o.start();
    setTimeout(()=>{ o.stop(); ctx.close(); }, 180);
  }catch(e){ console.warn('beep failed', e); }
}
function notifyUser(title, body, symbol){
  if(window.Notification && Notification.permission === 'granted'){
    const n = new Notification(title, { body }); n.onclick = ()=>{ window.focus(); openSymbol(symbol); };
  }
  const matchesEl = document.getElementById('matches');
  const note = document.createElement('div');
  note.className = 'notify';
  note.innerHTML = `<strong>${title}</strong> — ${body} <div style="margin-top:6px"><button onclick="openSymbol('${symbol}')">Open on Binance</button> <button onclick="copySym('${symbol}')">Copy</button></div>`;
  matchesEl.prepend(note);
  makeBeep();
}
function openSymbol(sym){
  const url = `https://www.binance.com/en/futures/${sym}`;
  window.open(url, '_blank');
}
function copySym(sym){
  navigator.clipboard?.writeText(sym).then(()=>alert(sym+' copied to clipboard')).catch(()=>alert('Copy failed'));
}

/* ---------------------------
   Two-phase scan: runScan()
   Uses strict quoteVol detector in phase B and counts ignore reasons
   --------------------------- */
function setStatus(s){ document.getElementById('status').textContent = s; }
function setDebug(s){ document.getElementById('debugLine').textContent = 'Debug: '+s; }

async function runScan(){
  setStatus('Fetching 24h tickers (phase A source list)...');
  let tickers;
  try{ tickers = await fetch24hrAll(); }
  catch(e){ console.error(e); setStatus('Error fetching 24hr tickers — see console'); document.getElementById('matches').innerText = 'Fetch error: '+e.message; return; }

  // phase 0: filter USDT & positive 24h, sort by pct desc, take top N, apply blacklist
  const topN = Math.max(1, Math.min(200, Number(document.getElementById('topN').value || 30)));
  const greenPairsAll = tickers.filter(t => typeof t.symbol === 'string' && t.symbol.endsWith('USDT'))
    .filter(t => safeNum(t.priceChangePercent) > 0)
    .map(t=>({symbol:t.symbol, pct:safeNum(t.priceChangePercent)}));
  greenPairsAll.sort((a,b)=> b.pct - a.pct);
  const topCandidates = greenPairsAll.slice(0, topN);
  const topAfterBlacklist = topCandidates.filter(p => !blacklist.includes(p.symbol));
  const filteredCount = topCandidates.length - topAfterBlacklist.length;
  document.getElementById('blacklistInfo').textContent = `Blacklist: ${blacklist.length} symbols filtered — ${filteredCount} removed from top${topN}`;
  document.getElementById('topInfo').textContent = `Top-N selected: ${topCandidates.length} (after blacklist: ${topAfterBlacklist.length})`;
  setDebug(`topCandidates=${topCandidates.length} (showing first 8): ${topCandidates.slice(0,8).map(x=>x.symbol).join(', ')}`);
  if(topAfterBlacklist.length === 0){ setStatus('No top-N green USDT pairs (after blacklist)'); document.getElementById('matches').innerText='No top-N pairs'; return; }

  // phase A: fetch klines for topAfterBlacklist in batches and compute last-close > EMA200 — collect EMA-OK symbols + store klines
  setStatus('Phase A: fetching klines & checking last-close > EMA200 (this may take a while)...');
  const batchSize = Number(document.getElementById('batchSize').value) || 3;
  const volRatio = Math.max(0.1, Number(document.getElementById('volRatio').value) || 1.0);

  const emaOkSymbols = [];
  const klinesMap = {}; // symbol -> klines array
  let fetchFailed = 0;

  await batchMap(topAfterBlacklist, async (p) => {
    try{
      const kl = await fetchKlines(p.symbol);
      const emaOk = isLastCloseAboveEMA200(kl);
      if(emaOk){
        emaOkSymbols.push({symbol:p.symbol, pct:p.pct});
        klinesMap[p.symbol] = kl;
      }
      return true;
    }catch(e){
      console.warn('fetch failed (phase A):', p.symbol, e.message);
      fetchFailed++;
      return {symbol:p.symbol,__err:e.message};
    }
  }, batchSize, 700);

  setDebug(`EMA-OK count: ${emaOkSymbols.length}`);
  document.getElementById('emaInfo').textContent = `EMA-OK: ${emaOkSymbols.length} symbols (last close > EMA200) — fetch failed: ${fetchFailed}`;
  document.getElementById('emaSymbols').textContent = emaOkSymbols.length ? emaOkSymbols.map(s=>s.symbol).join(', ') : 'None';

  if(emaOkSymbols.length === 0){
    setStatus('Phase A complete — no EMA-OK symbols');
    document.getElementById('matches').innerHTML = `<div>No EMA-OK symbols detected in this scan. (fetch failed: ${fetchFailed})</div>`;
    return;
  }

  // phase B: run the strict 24h-highest-red-break detector only on EMA-OK symbols (use klinesMap)
  setStatus(`Phase B: checking 24h red-break on ${emaOkSymbols.length} EMA-OK symbols`);
  const results = [];
  let brokenAtLowerCount = 0;
  let greenMadeDayHighCount = 0;

  for(const p of emaOkSymbols){
    try{
      const kl = klinesMap[p.symbol];
      const match = detect24hHighestRedBreak_quote(kl, volRatio);
      if(match && match.found){
        results.push({symbol:p.symbol, pct:p.pct, match});
      }else if(match && match.reason === 'broken_earlier_at_lower_price'){
        brokenAtLowerCount++;
        console.debug('ignored-broken-lower', p.symbol, match);
      }else if(match && match.reason === 'green_made_day_high'){
        greenMadeDayHighCount++;
        console.debug('ignored-green-made-day-high', p.symbol, match);
      }else{
        console.debug('no 24h-red-break (phase B):', p.symbol);
      }
    }catch(e){
      console.warn('phase B failed for', p.symbol, e.message);
    }
  }

  const el = document.getElementById('matches');
  if(results.length === 0){
    el.innerHTML = `<div>No matches detected in this scan (phase B). EMA-OK checked: ${emaOkSymbols.length} — fetch failed: ${fetchFailed}</div>
      <div style="margin-top:8px;color:#9fb3cc">Ignored because broken at lower price: ${brokenAtLowerCount} — Ignored (green made day-high): ${greenMadeDayHighCount}</div>`;
    setStatus('Scan complete — no matches');
    return;
  }

  // render matches + notify
  let html = '<table><thead><tr><th>Symbol</th><th>24h%</th><th>Red time</th><th>Red quoteVol</th><th>Red high</th><th>Green time</th><th>Green quoteVol</th><th>Green high</th><th>DayHigh</th><th>Actions</th></tr></thead><tbody>';
  for(const r of results){
    const m = r.match;
    html += `<tr class="match-row">
      <td>${r.symbol}</td>
      <td>${Number(r.pct).toFixed(2)}%</td>
      <td>${fmtTime(last24IndexToAbsTime(m.redIndex24h, klinesMap[r.symbol]))}</td>
      <td>${fmt(m.redQuoteVol)}</td>
      <td>${fmtPrice(m.redCandle.high)}</td>
      <td>${fmtTime(last24IndexToAbsTime(m.greenIndex24h, klinesMap[r.symbol]))}</td>
      <td class="ok">${fmt(m.greenQuoteVol)}</td>
      <td>${fmtPrice(m.greenCandle.high)}</td>
      <td>${fmtPrice(m.dayHigh)}</td>
      <td><button onclick="openSymbol('${r.symbol}')">Open</button> <button onclick="copySym('${r.symbol}')">Copy</button></td>
    </tr>`;
    const body = `24h highest red quoteVol ${fmt(m.redQuoteVol)} — green quoteVol ${fmt(m.greenQuoteVol)} (green.high < dayHigh)`;
    notifyUser('24h Red-Vol Break: '+r.symbol, body, r.symbol);
    if(document.getElementById('autoOpen').checked){
      try{ openSymbol(r.symbol); }catch(e){ console.warn('auto-open failed', e); }
    }
  }
  html += '</tbody></table>';
  html += `<div style="margin-top:8px;color:#9fb3cc">Ignored because broken at lower price: ${brokenAtLowerCount} — Ignored (green made day-high): ${greenMadeDayHighCount}</div>`;
  el.innerHTML = html;
  window._lastMatches = results;
  setStatus('Scan complete — matches: '+results.length);
}

/* ---------------------------
   Helpers to convert the last24 index back to real openTime for display
   We stored klinesMap[symbol] as full klines; detect uses kl.slice(-96)
   so mapping idx -> klines[kl.length-96 + idx].openTime
*/
function last24IndexToAbsTime(idx24, fullKlines){
  try{
    const full = fullKlines || [];
    const offset = Math.max(0, full.length - 96);
    const pos = offset + idx24;
    return full[pos] ? full[pos].openTime : null;
  }catch(e){ return null; }
}

/* ---------------------------
   fetch24hrAll helper
   --------------------------- */
async function fetch24hrAll(){
  const res = await fetch(API_BASE + '/fapi/v1/ticker/24hr');
  if(!res.ok) throw new Error('24hr fetch failed: '+res.status);
  return res.json();
}

/* ---------------------------
   Controls & test + blacklist update
   --------------------------- */
document.getElementById('startBtn').addEventListener('click', ()=>{
  if(controller.running) return;
  controller.running = true;
  document.getElementById('startBtn').disabled = true;
  document.getElementById('stopBtn').disabled = false;
  startLoop();
});
document.getElementById('stopBtn').addEventListener('click', ()=>{
  controller.running = false;
  document.getElementById('startBtn').disabled = false;
  document.getElementById('stopBtn').disabled = true;
  setStatus('Stopped');
});

async function startLoop(){
  if(window.Notification && Notification.permission !== 'granted' && Notification.permission !== 'denied'){
    try{ await Notification.requestPermission(); }catch(e){ console.warn('notification request failed', e); }
  }
  setStatus('Scanner running');
  while(controller.running){
    try{ await runScan(); }catch(e){ console.error('scan error', e); setStatus('Scan error — see console'); }
    if(!controller.running) break;
    const poll = Math.max(10, Number(document.getElementById('pollSec').value || 60));
    await sleep(poll * 1000);
  }
}

// single-symbol test (shows quoteVol-aware check)
document.getElementById('testBtn').addEventListener('click', async ()=>{
  const s = (document.getElementById('testSymbol').value || 'BTCUSDT').trim().toUpperCase();
  const out = document.getElementById('testOut');
  const st = document.getElementById('testStatus');
  st.textContent = 'Fetching klines...';
  out.textContent = '';
  try{
    const k = await fetchKlines(s);
    st.textContent = 'Checking last-close > EMA200 & 24h red-break (quoteVol strict)...';
    const emaOk = isLastCloseAboveEMA200(k);
    const vr = Number(document.getElementById('volRatio').value) || 1.0;
    const match = detect24hHighestRedBreak_quote(k, vr);
    out.textContent = `Klines fetched: ${k.length}\nLast close > EMA200: ${emaOk}\n\n24h red-break result:\n${match ? JSON.stringify(match, null, 2) : 'No pattern / insufficient data'}`;
    st.textContent = 'Done';
    console.log('Test klines sample:', k.slice(-24));
  }catch(e){
    st.textContent = 'Error';
    out.textContent = 'Error: ' + (e.message || String(e));
    console.error(e);
  }
});

// update blacklist
document.getElementById('updateBlacklistBtn').addEventListener('click', ()=>{
  const text = document.getElementById('blacklistArea').value || '';
  const lines = text.split(/\r?\n/).map(s => s.trim().toUpperCase()).filter(Boolean);
  blacklist = Array.from(new Set(lines));
  document.getElementById('blacklistInfo').textContent = `Blacklist: ${blacklist.length} symbols filtered`;
  alert('Blacklist updated — ' + blacklist.length + ' symbols');
});

/* ---------------------------
   Expose utilities + error logging
   --------------------------- */
window.openSymbol = openSymbol;
window.copySym = copySym;
window.addEventListener('error', e=>console.error('Runtime error', e));
</script>
</body>
</html>
